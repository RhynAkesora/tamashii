<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>魂テトリスVer.1</title>
    <style>
        html, body { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            position: fixed;
        }
        
        body { 
            background-color: #f0f0f0; 
            font-family: Arial, sans-serif; 
        }
        
        #gameContainer { 
            position: absolute; 
            width: 100%; 
            height: 100%; 
            display: flex; 
            flex-direction: column; 
            justify-content: flex-start;
            align-items: center; 
        }
        
        canvas { 
            border: 1px solid #000; 
            max-width: 100%; 
            max-height: calc(100% - 30px); 
        }
        
        #scoreDisplay {
            width: 100%;
            height: 30px;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 2px black;
            line-height: 30px;
            background-color: rgba(0, 0, 0, 0.5);
            text-align: center;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }
        
        #comboDisplay { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 24px;
            color: white; 
            text-shadow: 2px 2px 4px black; 
            display: none; 
            z-index: 20;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="scoreDisplay">スコア: 0 最高コンボ: 0 速度: 1.00x</div>
        <canvas id="gameCanvas"></canvas>
        <div id="comboDisplay"></div>
    </div>

    <script>
        // Canvas要素とコンテキストの取得
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplayElement = document.getElementById('scoreDisplay');
        const comboDisplayElement = document.getElementById('comboDisplay');

        // ゲーム設定
        const gridWidth = 10;
        const gridHeight = 14;
        const cellDivisions = 5;
        const colors = ['#FF0000', '#0000FF', '#00FF00', '#FFFF00'];
        
        // テトリスピースの定義
        const pieces = [
            [[1,1,1,1]], // I字
            [[1,1],[1,1]], // O字
            [[1,1,1],[0,1,0]], // T字
            [[1,1,1],[1,0,0]], // L字
            [[1,1,1],[0,0,1]], // J字
            [[1,1,0],[0,1,1]], // S字
            [[0,1,1],[1,1,0]]  // Z字
        ];

        // UI設定
        const NEXT_PIECE_PADDING = 10;
        const NEXT_PIECE_LABEL = 'NEXT';
        const SPEED_INCREASE_RATE = 0.99;
        const SPEED_INCREASE_INTERVAL = 5;
        const comboTimeThreshold = 1000;

        // ゲーム変数
        let cellSize, sandSize;
        let sandParticles = [];
        let currentPiece;
        let nextPiece;
        let score = 0;
        let gameLoop;
        let frameCount = 0;
        let isSettling = false;
        let isClearing = false;
        let comboCount = 0;
        let maxCombo = 0;
        let gameState = 'title';
        let comboDisplayTimeout;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let isTouchHolding = false;
        let lastClearedTime = 0;
        let fallSpeed = 30;
        let totalRows = 0;
        let yogaImage = null;
        let bgmAudio = null;
        let gameoverBgmAudio = null;

        /**
         * キャンバスサイズを画面に合わせてリサイズする
         */
        function resizeCanvas() {
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight - 30;
            const nextPieceWidth = Math.ceil(gridWidth * 0.4);
            const aspectRatio = (gridWidth + nextPieceWidth) / gridHeight;
            let newWidth, newHeight;

            if (containerWidth / containerHeight > aspectRatio) {
                newHeight = containerHeight;
                newWidth = newHeight * aspectRatio;
            } else {
                newWidth = containerWidth;
                newHeight = newWidth / aspectRatio;
            }

            cellSize = Math.floor(Math.min(newWidth / (gridWidth + nextPieceWidth), newHeight / gridHeight));
            sandSize = cellSize / cellDivisions;
            canvas.width = cellSize * (gridWidth + nextPieceWidth);
            canvas.height = cellSize * gridHeight;

            canvas.style.width = `${canvas.width}px`;
            canvas.style.height = `${canvas.height}px`;

            canvas.style.position = 'absolute';
            canvas.style.left = `${(containerWidth - canvas.width) / 2}px`;
            canvas.style.top = `${((containerHeight - canvas.height) / 2) + 30}px`;
        }

        /**
         * 新しいテトリスピースを作成する
         */
        function createPiece() {
            const pieceType = Math.floor(Math.random() * pieces.length);
            const colorIndex = Math.floor(Math.random() * colors.length);
            return {
                shape: pieces[pieceType],
                color: colorIndex,
                x: Math.floor(gridWidth / 2) - Math.floor(pieces[pieceType][0].length / 2),
                y: 0
            };
        }

        /**
         * ゲームグリッドと砂粒子を描画する
         */
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 砂漠の背景を描画
            drawDesertBackground();
            
            // ゲームエリアの背景を描画
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, cellSize * gridWidth, canvas.height);

            // 砂粒子を描画
            for (const particle of sandParticles) {
                ctx.fillStyle = colors[particle.color];
                ctx.fillRect(particle.x * sandSize, particle.y * sandSize, sandSize, sandSize);
            }
        }

        /**
         * 砂漠の背景を描画する
         */
        function drawDesertBackground() {
            const gameAreaWidth = cellSize * gridWidth;
            const nextAreaX = gameAreaWidth;
            const nextAreaWidth = canvas.width - gameAreaWidth;
            
            // 上部の砂漠エリア
            drawDesertArea(nextAreaX, 0, nextAreaWidth, canvas.height * 0.3);
            
            // 下部の砂漠エリア
            drawDesertArea(nextAreaX, canvas.height * 0.7, nextAreaWidth, canvas.height * 0.3);
            
            // 右側全体の基本砂漠背景
            const gradient = ctx.createLinearGradient(nextAreaX, 0, canvas.width, 0);
            gradient.addColorStop(0, '#f4a460'); // サンディブラウン
            gradient.addColorStop(0.5, '#daa520'); // ゴールデンロッド
            gradient.addColorStop(1, '#cd853f'); // ペルー
            
            ctx.fillStyle = gradient;
            ctx.fillRect(nextAreaX, 0, nextAreaWidth, canvas.height);
        }

        /**
         * 砂漠エリアを描画する
         */
        function drawDesertArea(x, y, width, height) {
            // 砂漠のベースグラデーション
            const verticalGradient = ctx.createLinearGradient(x, y, x, y + height);
            verticalGradient.addColorStop(0, '#ffebb5'); // 明るい砂色
            verticalGradient.addColorStop(0.3, '#f4a460'); // サンディブラウン
            verticalGradient.addColorStop(0.7, '#daa520'); // ゴールデンロッド
            verticalGradient.addColorStop(1, '#b8860b'); // ダークゴールデンロッド
            
            ctx.fillStyle = verticalGradient;
            ctx.fillRect(x, y, width, height);
            
            // 砂丘の波形を描画
            drawSandDunes(x, y, width, height);
            
            // 砂の粒子エフェクト
            drawSandParticles(x, y, width, height);
            
            // 熱気の表現
            drawHeatShimmer(x, y, width, height);
        }

        /**
         * 砂丘の波形を描画する
         */
        function drawSandDunes(x, y, width, height) {
            const waveCount = 3;
            const time = Date.now() * 0.001; // ゆっくりとした動き
            
            for (let i = 0; i < waveCount; i++) {
                const waveY = y + (height / (waveCount + 1)) * (i + 1);
                const amplitude = height * 0.1;
                const frequency = 0.01;
                
                ctx.beginPath();
                ctx.moveTo(x, waveY);
                
                for (let px = x; px <= x + width; px += 2) {
                    const wave1 = Math.sin((px - x) * frequency + time + i) * amplitude;
                    const wave2 = Math.sin((px - x) * frequency * 2 + time * 1.5 + i) * amplitude * 0.5;
                    const finalY = waveY + wave1 + wave2;
                    ctx.lineTo(px, finalY);
                }
                
                ctx.lineTo(x + width, y + height);
                ctx.lineTo(x, y + height);
                ctx.closePath();
                
                const duneGradient = ctx.createLinearGradient(x, waveY - amplitude, x, waveY + amplitude);
                duneGradient.addColorStop(0, 'rgba(255, 235, 181, 0.6)'); // 明るい砂色
                duneGradient.addColorStop(1, 'rgba(218, 165, 32, 0.3)'); // 濃い砂色
                
                ctx.fillStyle = duneGradient;
                ctx.fill();
            }
        }

        /**
         * 砂の粒子エフェクトを描画する
         */
        function drawSandParticles(x, y, width, height) {
            const particleCount = Math.floor(width * height / 1000);
            
            ctx.fillStyle = 'rgba(255, 235, 181, 0.4)';
            
            for (let i = 0; i < particleCount; i++) {
                const px = x + (i * 17) % width;
                const py = y + (i * 13) % height;
                const size = Math.random() * 2 + 1;
                
                ctx.beginPath();
                ctx.arc(px, py, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        /**
         * 熱気の表現を描画する
         */
        function drawHeatShimmer(x, y, width, height) {
            const shimmerCount = 5;
            const time = Date.now() * 0.003;
            
            for (let i = 0; i < shimmerCount; i++) {
                const shimmerX = x + (width / shimmerCount) * i + width / (shimmerCount * 2);
                const shimmerHeight = height * 0.8;
                
                const gradient = ctx.createLinearGradient(shimmerX, y, shimmerX, y + shimmerHeight);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                
                const waveOffset = Math.sin(time + i) * 5;
                ctx.fillRect(shimmerX + waveOffset, y, 3, shimmerHeight);
            }
        }

        /**
         * 現在のピースを描画する
         */
        function drawPiece() {
            if (!currentPiece) return;
            ctx.fillStyle = colors[currentPiece.color];
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        ctx.fillRect(
                            (currentPiece.x + x) * cellSize, 
                            (currentPiece.y + y) * cellSize, 
                            cellSize - 1, 
                            cellSize - 1
                        );
                    }
                }
            }
        }

        /**
         * 次のピースを描画する
         */
        function drawNextPiece() {
            const nextPieceAreaWidth = canvas.width - cellSize * gridWidth;
            const nextPieceSize = Math.min(cellSize * 0.8, (nextPieceAreaWidth - NEXT_PIECE_PADDING * 2) / 4);
            const nextPieceX = cellSize * gridWidth + (nextPieceAreaWidth - nextPieceSize * 4) / 2;
            const nextPieceY = NEXT_PIECE_PADDING * 2 + 20;

            // 次のピースエリアの背景
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(cellSize * gridWidth, 0, nextPieceAreaWidth, canvas.height);

            // 境界線を描画
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cellSize * gridWidth, 0);
            ctx.lineTo(cellSize * gridWidth, canvas.height);
            ctx.stroke();

            // "NEXT"ラベルを描画
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(NEXT_PIECE_LABEL, cellSize * gridWidth + nextPieceAreaWidth / 2, NEXT_PIECE_PADDING + 20);

            // 次のピースの背景
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(nextPieceX, nextPieceY, nextPieceSize * 4, nextPieceSize * 4);

            // 次のピースを描画
            ctx.fillStyle = colors[nextPiece.color];
            for (let y = 0; y < nextPiece.shape.length; y++) {
                for (let x = 0; x < nextPiece.shape[y].length; x++) {
                    if (nextPiece.shape[y][x]) {
                        ctx.fillRect(
                            nextPieceX + (x + (4 - nextPiece.shape[y].length) / 2) * nextPieceSize,
                            nextPieceY + (y + (4 - nextPiece.shape.length) / 2) * nextPieceSize,
                            nextPieceSize - 1,
                            nextPieceSize - 1
                        );
                    }
                }
            }
        }

        /**
         * ピースが指定された方向に移動できるかチェックする
         */
        function canMove(dx, dy) {
            if (!currentPiece) return false;
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const newX = currentPiece.x + x + dx;
                        const newY = currentPiece.y + y + dy;
                        if (newX < 0 || newX >= gridWidth || newY >= gridHeight || 
                            sandParticles.some(p => Math.floor(p.x / cellDivisions) === newX && Math.floor(p.y / cellDivisions) === newY)) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        /**
         * ピースを回転させる
         */
        function rotate() {
            if (!currentPiece) return;
            const rotated = currentPiece.shape[0].map((_, i) => 
                currentPiece.shape.map(row => row[i]).reverse()
            );
            const previousShape = currentPiece.shape;
            currentPiece.shape = rotated;
            if (!canMove(0, 0)) {
                currentPiece.shape = previousShape;
            }
        }

        /**
         * ピースを砂粒子に変換してフィールドに配置する
         */
        function mergePiece() {
            if (!currentPiece) return;
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        for (let i = 0; i < cellDivisions; i++) {
                            for (let j = 0; j < cellDivisions; j++) {
                                sandParticles.push({
                                    x: (currentPiece.x + x) * cellDivisions + i,
                                    y: (currentPiece.y + y) * cellDivisions + j,
                                    color: currentPiece.color
                                });
                            }
                        }
                    }
                }
            }
            currentPiece = null;
            isSettling = true;
        }

        /**
         * 指定された色の連結成分を見つける
         */
        function findConnectedComponents(color) {
            const visited = new Set();
            const components = [];
            for (const particle of sandParticles) {
                if (particle.color === color && !visited.has(`${particle.x},${particle.y}`)) {
                    const component = new Set();
                    dfs(particle, color, visited, component);
                    components.push(component);
                }
            }
            return components;
        }

        /**
         * 深度優先探索で連結成分を探索する
         */
        function dfs(particle, color, visited, component) {
            const key = `${particle.x},${particle.y}`;
            if (visited.has(key)) return;
            visited.add(key);
            component.add(key);

            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            for (const [dx, dy] of directions) {
                const newX = particle.x + dx;
                const newY = particle.y + dy;
                const neighbor = sandParticles.find(p => 
                    p.x === newX && p.y === newY && p.color === color
                );
                if (neighbor) {
                    dfs(neighbor, color, visited, component);
                }
            }
        }

        /**
         * 連結成分が横幅全体に渡っているかチェックする
         */
        function isFullWidth(component) {
            let minX = gridWidth * cellDivisions;
            let maxX = 0;
            for (const key of component) {
                const [x, _] = key.split(',').map(Number);
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
            }
            return maxX - minX + 1 === gridWidth * cellDivisions;
        }

        /**
         * 指定された連結成分の砂粒子を削除する
         */
        function removeSandParticles(component) {
            sandParticles = sandParticles.filter(p => !component.has(`${p.x},${p.y}`));
        }

        /**
         * コンボスコアを計算する
         */
        function calculateComboScore(combo, lines) {
            const baseScore = lines * 100;
            const baseMultiplier = 1.5;
            let multiplier = Math.pow(baseMultiplier, combo - 1);
            return Math.floor(baseScore * multiplier);
        }

        /**
         * コンボ表示を画面に表示する
         */
        function showComboDisplay(combo) {
            if (combo < 2) return;
            const multiplier = Math.pow(1.5, combo - 1).toFixed(2);
            comboDisplayElement.textContent = `${combo} コンボ! (x${multiplier})`;
            comboDisplayElement.style.display = 'block';
            clearTimeout(comboDisplayTimeout);
            comboDisplayTimeout = setTimeout(() => {
                comboDisplayElement.style.display = 'none';
            }, 2000);
        }

        /**
         * ラインを消去できるかチェックして消去する
         */
        function checkAndClearLines() {
            let cleared = false;
            let clearedLines = 0;
            for (let color = 0; color < colors.length; color++) {
                const connectedComponents = findConnectedComponents(color);
                for (const component of connectedComponents) {
                    if (isFullWidth(component)) {
                        removeSandParticles(component);
                        cleared = true;
                        clearedLines++;
                    }
                }
            }
            
            const currentTime = Date.now();
            if (cleared) {
                if (currentTime - lastClearedTime < comboTimeThreshold) {
                    comboCount++;
                } else {
                    comboCount = 1;
                }
                lastClearedTime = currentTime;
                
                const comboScore = calculateComboScore(comboCount, clearedLines);
                score += comboScore;
                showComboDisplay(comboCount);
                maxCombo = Math.max(maxCombo, comboCount);
            }
            
            return cleared;
        }

        /**
         * 砂粒子の物理シミュレーションを実行する
         */
        function simulateSand() {
            let moved = false;
            sandParticles.sort((a, b) => b.y - a.y);
            for (const particle of sandParticles) {
                if (particle.y < gridHeight * cellDivisions - 1 && 
                    !sandParticles.some(p => p.x === particle.x && p.y === particle.y + 1)) {
                    particle.y++;
                    moved = true;
                } else if (particle.y < gridHeight * cellDivisions - 1) {
                    const leftClear = particle.x > 0 && 
                        !sandParticles.some(p => p.x === particle.x - 1 && p.y === particle.y + 1);
                    const rightClear = particle.x < gridWidth * cellDivisions - 1 && 
                        !sandParticles.some(p => p.x === particle.x + 1 && p.y === particle.y + 1);
                    
                    if (leftClear && rightClear) {
                        particle.x += Math.random() < 0.5 ? -1 : 1;
                        particle.y++;
                        moved = true;
                    } else if (leftClear) {
                        particle.x--;
                        particle.y++;
                        moved = true;
                    } else if (rightClear) {
                        particle.x++;
                        particle.y++;
                        moved = true;
                    }
                }
            }
            return moved;
        }

        /**
         * スコア表示を更新する
         */
        function updateScoreDisplay() {
            scoreDisplayElement.textContent = 
                `スコア: ${score} 最高コンボ: ${maxCombo}x 速度: ${(30 / fallSpeed).toFixed(2)}x`;
        }

        /**
         * ゲームオーバー処理
         */
        function gameOver() {
            gameState = 'gameOver';
            cancelAnimationFrame(gameLoop);
            stopBGM(); // ゲーム中のBGMを停止
            playGameOverBGM(); // ゲームオーバー用BGMを再生
            drawGameOverScreen();
        }

        /**
         * タイトル画面を描画する
         */
        function drawTitleScreen() {
            ctx.fillStyle = 'linear-gradient(180deg, #2c5aa0 0%, #5b3a8f 50%, #1a1a2e 100%)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 背景グラデーション
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#2c5aa0');
            gradient.addColorStop(0.5, '#5b3a8f');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 星を描画
            ctx.fillStyle = 'white';
            for (let i = 0; i < 20; i++) {
                const x = (i * 47) % canvas.width;
                const y = (i * 23) % (canvas.height * 0.6);
                ctx.fillRect(x, y, 2, 2);
            }

            // ヨガ行者のドット絵を描画
            drawYogaMonk();

            // 画面サイズに応じてフォントサイズを調整
            const isSmallScreen = canvas.height < 600;
            const titleFontSize = isSmallScreen ? 24 : 32;
            const subtitleFontSize = isSmallScreen ? 14 : 16;
            const instructionFontSize = isSmallScreen ? 16 : 18;
            const versionFontSize = isSmallScreen ? 12 : 14;

            // タイトルテキスト
            ctx.fillStyle = 'white';
            ctx.font = `bold ${titleFontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeText('魂テトリス', canvas.width / 2, canvas.height * 0.15);
            ctx.fillText('魂テトリス', canvas.width / 2, canvas.height * 0.15);

            // サブタイトル
            ctx.font = `${subtitleFontSize}px Arial`;
            ctx.fillStyle = '#cccccc';
            ctx.fillText('~ Soul Tetris ~', canvas.width / 2, canvas.height * 0.22);

            // ハイスコアボタン
            drawHighScoreButton();

            // ゲーム開始の説明（ボタンの下に配置）
            ctx.font = `${instructionFontSize}px Arial`;
            ctx.fillStyle = 'white';
            const instructionY = isSmallScreen ? canvas.height * 0.88 : canvas.height * 0.85;
            ctx.fillText('画面をタップしてゲーム開始', canvas.width / 2, instructionY);

            // バージョン情報（右下に配置）
            ctx.font = `${versionFontSize}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.textAlign = 'right';
            ctx.fillText('Ver. 0.51', canvas.width - 10, canvas.height - 10);
        }

        /**
         * BGMを読み込む
         */
        function loadBGM() {
            try {
                bgmAudio = new Audio('soul-stage.mp3');
                bgmAudio.loop = true; // リピート再生を有効化
                bgmAudio.volume = 0.7; // 音量を少し下げる
                bgmAudio.preload = 'auto';
                
                bgmAudio.addEventListener('canplaythrough', () => {
                    console.log('BGMの読み込み完了');
                });
                
                bgmAudio.addEventListener('error', (e) => {
                    console.error('BGMの読み込みに失敗しました:', e);
                    bgmAudio = null;
                });
            } catch (error) {
                console.error('BGMの初期化に失敗しました:', error);
                bgmAudio = null;
            }
        }

        /**
         * ゲームオーバー用BGMを読み込む
         */
        function loadGameOverBGM() {
            try {
                gameoverBgmAudio = new Audio('soul-gameover.mp3');
                gameoverBgmAudio.loop = false; // リピートしない
                gameoverBgmAudio.volume = 0.7; // 音量を少し下げる
                gameoverBgmAudio.preload = 'auto';
                
                gameoverBgmAudio.addEventListener('canplaythrough', () => {
                    console.log('ゲームオーバーBGMの読み込み完了');
                });
                
                gameoverBgmAudio.addEventListener('error', (e) => {
                    console.error('ゲームオーバーBGMの読み込みに失敗しました:', e);
                    gameoverBgmAudio = null;
                });
            } catch (error) {
                console.error('ゲームオーバーBGMの初期化に失敗しました:', error);
                gameoverBgmAudio = null;
            }
        }

        /**
         * BGMを再生する
         */
        function playBGM() {
            if (bgmAudio) {
                try {
                    bgmAudio.currentTime = 0; // 最初から再生
                    const playPromise = bgmAudio.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('BGM再生開始');
                        }).catch((error) => {
                            console.error('BGM再生に失敗しました:', error);
                        });
                    }
                } catch (error) {
                    console.error('BGM再生エラー:', error);
                }
            }
        }

        /**
         * BGMを停止する
         */
        function stopBGM() {
            if (bgmAudio) {
                try {
                    bgmAudio.pause();
                    bgmAudio.currentTime = 0;
                    console.log('BGM停止');
                } catch (error) {
                    console.error('BGM停止エラー:', error);
                }
            }
        }

        /**
         * ゲームオーバー用BGMを再生する
         */
        function playGameOverBGM() {
            if (gameoverBgmAudio) {
                try {
                    gameoverBgmAudio.currentTime = 0; // 最初から再生
                    const playPromise = gameoverBgmAudio.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('ゲームオーバーBGM再生開始');
                        }).catch((error) => {
                            console.error('ゲームオーバーBGM再生に失敗しました:', error);
                        });
                    }
                } catch (error) {
                    console.error('ゲームオーバーBGM再生エラー:', error);
                }
            }
        }

        /**
         * ゲームオーバー用BGMを停止する
         */
        function stopGameOverBGM() {
            if (gameoverBgmAudio) {
                try {
                    gameoverBgmAudio.pause();
                    gameoverBgmAudio.currentTime = 0;
                    console.log('ゲームオーバーBGM停止');
                } catch (error) {
                    console.error('ゲームオーバーBGM停止エラー:', error);
                }
            }
        }
        function loadYogaImage() {
            const img = new Image();
            img.onload = () => {
                yogaImage = img;
                console.log('ヨガ画像の読み込み成功');
                if (gameState === 'title') {
                    drawTitleScreen();
                }
            };
            img.onerror = () => {
                console.error('ヨガ画像の読み込みに失敗しました');
                yogaImage = null;
            };
            img.src = 'yoga01.png';
        }

        /**
         * ヨガ行者の画像を描画する
         */
        function drawYogaMonk() {
            if (!yogaImage) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // 画像のサイズを画面に合わせて調整
            const maxImageWidth = canvas.width * 0.4;
            const maxImageHeight = canvas.height * 0.4;
            
            const scale = Math.min(
                maxImageWidth / yogaImage.width,
                maxImageHeight / yogaImage.height
            );
            
            const imageWidth = yogaImage.width * scale;
            const imageHeight = yogaImage.height * scale;
            
            const imageX = centerX - imageWidth / 2;
            const imageY = centerY - imageHeight / 2 - 20;

            // 光輪（オーラ）を背景に描画
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY - 20, Math.max(imageWidth, imageHeight) / 2 + 40, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY - 20, Math.max(imageWidth, imageHeight) / 2 + 60, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerX, centerY - 20, Math.max(imageWidth, imageHeight) / 2 + 80, 0, Math.PI * 2);
            ctx.stroke();

            // ヨガ行者の画像を描画
            ctx.drawImage(yogaImage, imageX, imageY, imageWidth, imageHeight);
        }

        /**
         * ハイスコアボタンを描画する
         */
        function drawHighScoreButton() {
            const isSmallScreen = canvas.height < 600;
            const buttonWidth = Math.min(canvas.width * 0.3, 200);
            const buttonHeight = isSmallScreen ? 35 : 40;
            const buttonX = canvas.width / 2 - buttonWidth / 2;
            const buttonY = canvas.height * (isSmallScreen ? 0.70 : 0.75);

            // ボタンの背景
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
            
            // ボタンの境界線
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);

            // ボタンテキスト
            ctx.fillStyle = 'white';
            ctx.font = `${isSmallScreen ? 16 : 18}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('ハイスコア', canvas.width / 2, buttonY + (buttonHeight / 2) + 5);
        }

        /**
         * ハイスコア画面を描画する
         */
        function drawHighScoreScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'white';
            ctx.font = '28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ハイスコア', canvas.width / 2, canvas.height * 0.3);
            
            ctx.font = '20px Arial';
            ctx.fillText('1位: 50,000', canvas.width / 2, canvas.height * 0.45);
            ctx.fillText('2位: 35,000', canvas.width / 2, canvas.height * 0.52);
            ctx.fillText('3位: 20,000', canvas.width / 2, canvas.height * 0.59);
            ctx.fillText('4位: 15,000', canvas.width / 2, canvas.height * 0.66);
            ctx.fillText('5位: 10,000', canvas.width / 2, canvas.height * 0.73);
            
            ctx.font = '16px Arial';
            ctx.fillStyle = '#cccccc';
            ctx.fillText('画面をタップして戻る', canvas.width / 2, canvas.height * 0.85);
        }

        /**
         * ハイスコアボタンがタップされたかチェックする
         */
        function isHighScoreButtonTapped(x, y) {
            const isSmallScreen = canvas.height < 600;
            const buttonWidth = Math.min(canvas.width * 0.3, 200);
            const buttonHeight = isSmallScreen ? 35 : 40;
            const buttonX = canvas.width / 2 - buttonWidth / 2;
            const buttonY = canvas.height * (isSmallScreen ? 0.70 : 0.75);
            
            return x >= buttonX && x <= buttonX + buttonWidth && 
                   y >= buttonY && y <= buttonY + buttonHeight;
        }

        /**
         * ゲームオーバー画面を描画する
         */
        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ゲームオーバー', canvas.width / 2, canvas.height / 2 - 40);
            ctx.font = '20px Arial';
            ctx.fillText(`最終スコア: ${score}`, canvas.width / 2, canvas.height / 2);
            ctx.font = '16px Arial';
            ctx.fillStyle = '#cccccc';
            ctx.fillText('タップしてタイトルに戻る', canvas.width / 2, canvas.height / 2 + 40);
        }

        /**
         * ゲームをリセットして新しいゲームを開始する
         */
        function resetGame() {
            sandParticles = [];
            score = 0;
            comboCount = 0;
            maxCombo = 0;
            isSettling = false;
            isClearing = false;
            frameCount = 0;
            lastClearedTime = 0;
            currentPiece = createPiece();
            nextPiece = createPiece();
            fallSpeed = 30;
            totalRows = 0;
            updateScoreDisplay();
            gameState = 'playing';
            
            // BGMを再生開始
            playBGM();
            
            update();
        }

        /**
         * メインゲームループ
         */
        function update() {
            if (gameState !== 'playing') return;

            frameCount++;
            
            // ピースの自動落下
            if (frameCount % Math.floor(fallSpeed) === 0 && !isSettling && !isClearing && currentPiece) {
                if (canMove(0, 1)) {
                    currentPiece.y++;
                    score++;
                    totalRows++;
                    
                    // スピードアップ
                    if (totalRows % SPEED_INCREASE_INTERVAL === 0) {
                        fallSpeed *= SPEED_INCREASE_RATE;
                    }
                } else {
                    mergePiece();
                    isSettling = true;
                }
            }

            // 砂粒子の物理シミュレーション
            if (isSettling) {
                if (!simulateSand()) {
                    isSettling = false;
                    isClearing = true;
                }
            }

            // ライン消去処理
            if (isClearing) {
                const cleared = checkAndClearLines();
                if (cleared) {
                    isSettling = true;
                } else {
                    isClearing = false;
                    if (!currentPiece) {
                        currentPiece = nextPiece;
                        nextPiece = createPiece();
                        if (!canMove(0, 0)) {
                            gameOver();
                            return;
                        }
                    }
                }
            }

            // 描画
            drawGrid();
            if (currentPiece && !isSettling && !isClearing) {
                drawPiece();
            }
            drawNextPiece();

            updateScoreDisplay();
            gameLoop = requestAnimationFrame(update);
        }

        /**
         * タッチ操作を処理する
         */
        function handleTouch(action) {
            if (gameState !== 'playing') return;

            switch (action) {
                case 'left':
                    if (canMove(-1, 0)) currentPiece.x--;
                    break;
                case 'right':
                    if (canMove(1, 0)) currentPiece.x++;
                    break;
                case 'rotate':
                    rotate();
                    break;
                case 'drop':
                    while (canMove(0, 1)) {
                        currentPiece.y++;
                        score++;
                        totalRows++;
                    }
                    mergePiece();
                    break;
            }
        }

        /**
         * キャンバスクリック処理
         */
        function handleCanvasClick(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (gameState === 'title') {
                if (isHighScoreButtonTapped(x, y)) {
                    gameState = 'highscore';
                    drawHighScoreScreen();
                } else {
                    resetGame();
                }
            } else if (gameState === 'highscore') {
                gameState = 'title';
                stopBGM(); // ゲーム中BGMを停止
                stopGameOverBGM(); // ゲームオーバーBGMを停止
                drawTitleScreen();
            } else if (gameState === 'gameOver') {
                gameState = 'title';
                stopBGM(); // ゲーム中BGMを停止
                stopGameOverBGM(); // ゲームオーバーBGMを停止
                drawTitleScreen();
            }
        }

        /**
         * イベントリスナーを初期化する
         */
        function initEventListeners() {
            // タッチイベント
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartTime = Date.now();
                isTouchHolding = true;
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (gameState !== 'playing') return;

                const touch = e.touches[0];
                const deltaX = touch.clientX - touchStartX;
                const deltaY = touch.clientY - touchStartY;

                // 横方向のスワイプ
                if (Math.abs(deltaX) > cellSize) {
                    handleTouch(deltaX > 0 ? 'right' : 'left');
                    touchStartX = touch.clientX;
                }

                // 下方向のスワイプ（ハードドロップ）
                if (deltaY > cellSize && isTouchHolding) {
                    handleTouch('drop');
                    isTouchHolding = false;
                }
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (gameState === 'playing') {
                    const touchEndTime = Date.now();
                    const touchDuration = touchEndTime - touchStartTime;

                    // 短いタップは回転
                    if (touchDuration < 200 && isTouchHolding) {
                        handleTouch('rotate');
                    }

                    isTouchHolding = false;
                } else {
                    // タイトル画面、ハイスコア画面、ゲームオーバー画面での処理
                    const touch = e.changedTouches[0];
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;

                    if (gameState === 'title') {
                        if (isHighScoreButtonTapped(x, y)) {
                            gameState = 'highscore';
                            drawHighScoreScreen();
                        } else {
                            resetGame();
                        }
                    } else if (gameState === 'highscore') {
                        gameState = 'title';
                        stopBGM(); // ゲーム中BGMを停止
                        stopGameOverBGM(); // ゲームオーバーBGMを停止
                        drawTitleScreen();
                    } else if (gameState === 'gameOver') {
                        gameState = 'title';
                        stopBGM(); // ゲーム中BGMを停止
                        stopGameOverBGM(); // ゲームオーバーBGMを停止
                        drawTitleScreen();
                    }
                }
            });

            // クリックイベント（デスクトップ用）
            canvas.addEventListener('click', handleCanvasClick);

            // ウィンドウリサイズ
            window.addEventListener('resize', () => {
                resizeCanvas();
                if (gameState === 'title') {
                    drawTitleScreen();
                } else if (gameState === 'highscore') {
                    drawHighScoreScreen();
                } else if (gameState === 'gameOver') {
                    drawGameOverScreen();
                }
            });

        }

        /**
         * ゲームを初期化する
         */
        function init() {
            resizeCanvas();
            initEventListeners();
            loadBGM(); // BGMを読み込む
            loadGameOverBGM(); // ゲームオーバーBGMを読み込む
            loadYogaImage(); // 画像を読み込む
            drawTitleScreen();
        }

        // ゲーム開始
        init();
    </script>
</body>
</html>
