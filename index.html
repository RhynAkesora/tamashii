<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>魂テトリス</title>
    
    <!-- PWA用メタタグ -->
    <meta name="description" content="瞑想的なテトリスゲーム - 魂テトリス">
    <meta name="theme-color" content="#2c5aa0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="魂テトリス">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- アイコン -->
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <style>
        html, body { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            position: fixed;
            background-color: #000; /* 背景を黒に */
        }
        
        body { 
            font-family: Arial, sans-serif; 
        }
        
        #gameContainer { 
            position: absolute; 
            width: 100%; 
            height: 100%; 
            display: flex; 
            flex-direction: column; 
            justify-content: flex-start;
            align-items: center; 
        }
        
        canvas { 
            border: 1px solid #000; 
            max-width: 100%; 
            max-height: calc(100% - 30px);
            display: block;
        }
        
        #scoreDisplay {
            height: 30px;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 2px black;
            line-height: 30px;
            background-color: rgba(0, 0, 0, 0.8);
            text-align: center;
            position: absolute;
            z-index: 10;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        #comboDisplay { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 24px;
            color: white; 
            text-shadow: 2px 2px 4px black; 
            display: none; 
            z-index: 20;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="scoreDisplay">スコア: 0 最高コンボ: 0 速度: 1.00x</div>
        <canvas id="gameCanvas"></canvas>
        <div id="comboDisplay"></div>
    </div>

    <script>
        // Canvas要素とコンテキストの取得
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplayElement = document.getElementById('scoreDisplay');
        const comboDisplayElement = document.getElementById('comboDisplay');

        // ゲーム設定
        const gridWidth = 10;
        const gridHeight = 14;
        const cellDivisions = 5;
        const colors = ['#FF0000', '#0000FF', '#00FF00', '#FFFF00'];
        
        // テトリスピースの定義
        const pieces = [
            [[1,1,1,1]], // I字
            [[1,1],[1,1]], // O字
            [[1,1,1],[0,1,0]], // T字
            [[1,1,1],[1,0,0]], // L字
            [[1,1,1],[0,0,1]], // J字
            [[1,1,0],[0,1,1]], // S字
            [[0,1,1],[1,1,0]]  // Z字
        ];

        // UI設定
        const NEXT_PIECE_PADDING = 10;
        const NEXT_PIECE_LABEL = 'NEXT';
        const SPEED_INCREASE_RATE = 0.99;
        const SPEED_INCREASE_INTERVAL = 5;
        const comboTimeThreshold = 1000;

        // ゲーム変数
        let cellSize, sandSize;
        let sandParticles = [];
        let currentPiece;
        let nextPiece;
        let score = 0;
        let gameLoop;
        let frameCount = 0;
        let isSettling = false;
        let isClearing = false;
        let comboCount = 0;
        let maxCombo = 0;
        let gameState = 'pleaseTap';
        let comboDisplayTimeout;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let isTouchHolding = false;
        let lastClearedTime = 0;
        let fallSpeed = 30;
        let totalRows = 0;
        let yogaImage = null;
        let bgmAudio = null;
        let gameoverBgmAudio = null;
        let titleBgmAudio = null;
        let pleaseTapAnimation = null;
        let pauseButton = { x: 0, y: 0, width: 0, height: 0 };

        /**
         * キャンバスサイズを画面に合わせてリサイズする
         */
        function resizeCanvas() {
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;
            const nextPieceWidth = Math.ceil(gridWidth * 0.4);
            const aspectRatio = (gridWidth + nextPieceWidth) / gridHeight;
            let newWidth, newHeight;

            if (containerWidth / containerHeight > aspectRatio) {
                newHeight = containerHeight * 0.8; // 画面の80%を使用してスコア表示の余裕を確保
                newWidth = newHeight * aspectRatio;
            } else {
                newWidth = containerWidth * 0.95; // 左右に少し余裕を持たせる
                newHeight = newWidth / aspectRatio;
            }

            cellSize = Math.floor(Math.min(newWidth / (gridWidth + nextPieceWidth), newHeight / gridHeight));
            sandSize = cellSize / cellDivisions;
            canvas.width = cellSize * (gridWidth + nextPieceWidth);
            canvas.height = cellSize * gridHeight;

            canvas.style.width = `${canvas.width}px`;
            canvas.style.height = `${canvas.height}px`;

            const canvasLeft = (containerWidth - canvas.width) / 2;
            const canvasTop = (containerHeight - canvas.height) / 2;

            canvas.style.position = 'absolute';
            canvas.style.left = `${canvasLeft}px`;
            canvas.style.top = `${canvasTop}px`;

            // スコア表示をキャンバスの直上に配置
            const scoreDisplay = document.getElementById('scoreDisplay');
            const scoreWidth = Math.min(canvas.width, containerWidth * 0.9);
            scoreDisplay.style.width = `${scoreWidth}px`;
            scoreDisplay.style.left = `${(containerWidth - scoreWidth) / 2}px`;
            scoreDisplay.style.top = `${Math.max(10, canvasTop - 40)}px`; // キャンバスの40px上、最低10pxは確保
        }

        /**
         * 新しいテトリスピースを作成する
         */
        function createPiece() {
            const pieceType = Math.floor(Math.random() * pieces.length);
            const colorIndex = Math.floor(Math.random() * colors.length);
            return {
                shape: pieces[pieceType],
                color: colorIndex,
                x: Math.floor(gridWidth / 2) - Math.floor(pieces[pieceType][0].length / 2),
                y: 0
            };
        }

        /**
         * ゲームグリッドと砂粒子を描画する
         */
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 砂漠の背景を描画 (for the right side 'NEXT' area)
            drawDesertBackground();
            
            // ゲームエリアの背景を水色で描画
            const gameAreaWidth = cellSize * gridWidth;
            const gameAreaHeight = canvas.height;
            ctx.fillStyle = '#add8e6'; // Light Blue
            ctx.fillRect(0, 0, gameAreaWidth, gameAreaHeight);

            // 砂粒子を描画
            for (const particle of sandParticles) {
                ctx.fillStyle = colors[particle.color];
                ctx.fillRect(particle.x * sandSize, particle.y * sandSize, sandSize, sandSize);
            }
        }

        /**
         * 砂漠の背景を描画する
         */
        function drawDesertBackground() {
            const gameAreaWidth = cellSize * gridWidth;
            const nextAreaX = gameAreaWidth;
            const nextAreaWidth = canvas.width - gameAreaWidth;
            
            // 右側全体の基本砂漠背景
            const gradient = ctx.createLinearGradient(nextAreaX, 0, canvas.width, 0);
            gradient.addColorStop(0, '#f4a460'); // サンディブラウン
            gradient.addColorStop(0.5, '#daa520'); // ゴールデンロッド
            gradient.addColorStop(1, '#cd853f'); // ペルー
            
            ctx.fillStyle = gradient;
            ctx.fillRect(nextAreaX, 0, nextAreaWidth, canvas.height);
        }

        /**
         * 現在のピースを描画する
         */
        function drawPiece() {
            if (!currentPiece) return;
            ctx.fillStyle = colors[currentPiece.color];
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        ctx.fillRect(
                            (currentPiece.x + x) * cellSize, 
                            (currentPiece.y + y) * cellSize, 
                            cellSize - 1, 
                            cellSize - 1
                        );
                    }
                }
            }
        }

        /**
         * 次のピースを描画する
         */
        function drawNextPiece() {
            if (!nextPiece) return;
            const nextPieceAreaWidth = canvas.width - cellSize * gridWidth;
            const nextPieceSize = Math.min(cellSize * 0.8, (nextPieceAreaWidth - NEXT_PIECE_PADDING * 2) / 4);
            const nextPieceX = cellSize * gridWidth + (nextPieceAreaWidth - nextPieceSize * 4) / 2;
            const nextPieceY = NEXT_PIECE_PADDING * 2 + 20;

            // 次のピースエリアの背景
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(cellSize * gridWidth, 0, nextPieceAreaWidth, canvas.height);

            // 境界線を描画
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cellSize * gridWidth, 0);
            ctx.lineTo(cellSize * gridWidth, canvas.height);
            ctx.stroke();

            // "NEXT"ラベルを描画
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(NEXT_PIECE_LABEL, cellSize * gridWidth + nextPieceAreaWidth / 2, NEXT_PIECE_PADDING + 20);

            // 次のピースの背景
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(nextPieceX, nextPieceY, nextPieceSize * 4, nextPieceSize * 4);

            // 次のピースを描画
            ctx.fillStyle = colors[nextPiece.color];
            for (let y = 0; y < nextPiece.shape.length; y++) {
                for (let x = 0; x < nextPiece.shape[y].length; x++) {
                    if (nextPiece.shape[y][x]) {
                        ctx.fillRect(
                            nextPieceX + (x + (4 - nextPiece.shape[y].length) / 2) * nextPieceSize,
                            nextPieceY + (y + (4 - nextPiece.shape.length) / 2) * nextPieceSize,
                            nextPieceSize - 1,
                            nextPieceSize - 1
                        );
                    }
                }
            }
        }

        /**
         * ピースが指定された方向に移動できるかチェックする
         */
        function canMove(dx, dy) {
            if (!currentPiece) return false;
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const newX = currentPiece.x + x + dx;
                        const newY = currentPiece.y + y + dy;
                        if (newX < 0 || newX >= gridWidth || newY >= gridHeight || 
                            sandParticles.some(p => Math.floor(p.x / cellDivisions) === newX && Math.floor(p.y / cellDivisions) === newY)) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        /**
         * ピースを回転させる
         */
        function rotate() {
            if (!currentPiece) return;
            const rotated = currentPiece.shape[0].map((_, i) => 
                currentPiece.shape.map(row => row[i]).reverse()
            );
            const previousShape = currentPiece.shape;
            currentPiece.shape = rotated;
            if (!canMove(0, 0)) {
                currentPiece.shape = previousShape;
            }
        }

        /**
         * ピースを砂粒子に変換してフィールドに配置する
         */
        function mergePiece() {
            if (!currentPiece) return;
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        for (let i = 0; i < cellDivisions; i++) {
                            for (let j = 0; j < cellDivisions; j++) {
                                sandParticles.push({
                                    x: (currentPiece.x + x) * cellDivisions + i,
                                    y: (currentPiece.y + y) * cellDivisions + j,
                                    color: currentPiece.color
                                });
                            }
                        }
                    }
                }
            }
            currentPiece = null;
            isSettling = true;
        }

        /**
         * 指定された色の連結成分を見つける
         */
        function findConnectedComponents(color) {
            const visited = new Set();
            const components = [];
            for (const particle of sandParticles) {
                if (particle.color === color && !visited.has(`${particle.x},${particle.y}`)) {
                    const component = new Set();
                    dfs(particle, color, visited, component);
                    components.push(component);
                }
            }
            return components;
        }

        /**
         * 深度優先探索で連結成分を探索する
         */
        function dfs(particle, color, visited, component) {
            const key = `${particle.x},${particle.y}`;
            if (visited.has(key)) return;
            visited.add(key);
            component.add(key);

            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            for (const [dx, dy] of directions) {
                const newX = particle.x + dx;
                const newY = particle.y + dy;
                const neighbor = sandParticles.find(p => 
                    p.x === newX && p.y === newY && p.color === color
                );
                if (neighbor) {
                    dfs(neighbor, color, visited, component);
                }
            }
        }

        /**
         * 連結成分が横幅全体に渡っているかチェックする
         */
        function isFullWidth(component) {
            let minX = gridWidth * cellDivisions;
            let maxX = 0;
            for (const key of component) {
                const [x, _] = key.split(',').map(Number);
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
            }
            return maxX - minX + 1 === gridWidth * cellDivisions;
        }

        /**
         * 指定された連結成分の砂粒子を削除する
         */
        function removeSandParticles(component) {
            sandParticles = sandParticles.filter(p => !component.has(`${p.x},${p.y}`));
        }

        /**
         * コンボスコアを計算する
         */
        function calculateComboScore(combo, lines) {
            const baseScore = lines * 100;
            const baseMultiplier = 1.5;
            let multiplier = Math.pow(baseMultiplier, combo - 1);
            return Math.floor(baseScore * multiplier);
        }

        /**
         * コンボ表示を画面に表示する
         */
        function showComboDisplay(combo) {
            if (combo < 2) return;
            const multiplier = Math.pow(1.5, combo - 1).toFixed(2);
            comboDisplayElement.textContent = `${combo} コンボ! (x${multiplier})`;
            comboDisplayElement.style.display = 'block';
            clearTimeout(comboDisplayTimeout);
            comboDisplayTimeout = setTimeout(() => {
                comboDisplayElement.style.display = 'none';
            }, 2000);
        }

        /**
         * ラインを消去できるかチェックして消去する
         */
        function checkAndClearLines() {
            let cleared = false;
            let clearedLines = 0;
            for (let color = 0; color < colors.length; color++) {
                const connectedComponents = findConnectedComponents(color);
                for (const component of connectedComponents) {
                    if (isFullWidth(component)) {
                        removeSandParticles(component);
                        cleared = true;
                        clearedLines++;
                    }
                }
            }
            
            const currentTime = Date.now();
            if (cleared) {
                if (currentTime - lastClearedTime < comboTimeThreshold) {
                    comboCount++;
                } else {
                    comboCount = 1;
                }
                lastClearedTime = currentTime;
                
                const comboScore = calculateComboScore(comboCount, clearedLines);
                score += comboScore;
                showComboDisplay(comboCount);
                maxCombo = Math.max(maxCombo, comboCount);
            }
            
            return cleared;
        }

        /**
         * 砂粒子の物理シミュレーションを実行する
         */
        function simulateSand() {
            let moved = false;
            sandParticles.sort((a, b) => b.y - a.y);
            for (const particle of sandParticles) {
                if (particle.y < gridHeight * cellDivisions - 1 && 
                    !sandParticles.some(p => p.x === particle.x && p.y === particle.y + 1)) {
                    particle.y++;
                    moved = true;
                } else if (particle.y < gridHeight * cellDivisions - 1) {
                    const leftClear = particle.x > 0 && 
                        !sandParticles.some(p => p.x === particle.x - 1 && p.y === particle.y + 1);
                    const rightClear = particle.x < gridWidth * cellDivisions - 1 && 
                        !sandParticles.some(p => p.x === particle.x + 1 && p.y === particle.y + 1);
                    
                    if (leftClear && rightClear) {
                        particle.x += Math.random() < 0.5 ? -1 : 1;
                        particle.y++;
                        moved = true;
                    } else if (leftClear) {
                        particle.x--;
                        particle.y++;
                        moved = true;
                    } else if (rightClear) {
                        particle.x++;
                        particle.y++;
                        moved = true;
                    }
                }
            }
            return moved;
        }

        /**
         * スコア表示を更新する
         */
        function updateScoreDisplay() {
            scoreDisplayElement.textContent = 
                `スコア: ${score} 最高コンボ: ${maxCombo}x 速度: ${(30 / fallSpeed).toFixed(2)}x`;
        }

        /**
         * ゲームオーバー処理
         */
        function gameOver() {
            gameState = 'gameOver';
            cancelAnimationFrame(gameLoop);
            stopBGM(); // ゲーム中のBGMを停止
            playGameOverBGM(); // ゲームオーバー用BGMを再生
            drawGameOverScreen();
        }

        /**
         * Please Tap画面のアニメーションループ
         */
        function animatePleaseTapScreen() {
            if (gameState === 'pleaseTap') {
                drawPleaseTapScreen();
                pleaseTapAnimation = requestAnimationFrame(animatePleaseTapScreen);
            }
        }
        
        /**
         * Please Tap画面を描画する
         */
        function drawPleaseTapScreen() {
            // 黒い背景
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 点滅効果の計算（1秒周期）
            const time = Date.now();
            const blinkCycle = (time % 1000) / 1000; // 0から1の範囲
            const opacity = 0.3 + 0.7 * Math.abs(Math.sin(blinkCycle * Math.PI)); // 0.3から1.0の範囲で点滅
            
            // 画面サイズに応じてフォントサイズを調整
            const isSmallScreen = canvas.height < 600;
            const pleaseTapFontSize = isSmallScreen ? 28 : 36;
            const pwaNoteFontSize = isSmallScreen ? 11 : 13;
            const creditFontSize = isSmallScreen ? 12 : 14;
            
            // Please Tapテキスト（点滅）
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.font = `bold ${pleaseTapFontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('Please Tap', canvas.width / 2, canvas.height / 2 - 20);
            
            // PWA案内（中央下）
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = `${pwaNoteFontSize}px Arial`;
            const pwaY = canvas.height / 2 + 60;
            ctx.fillText('※ホーム画面に追加でこのゲームをアプリ化', canvas.width / 2, pwaY);
            
            // クレジット表記（画面下部）
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = `${creditFontSize}px Arial`;
            const creditY = canvas.height - (isSmallScreen ? 20 : 30);
            ctx.fillText('Presented by Rhyn皇太子', canvas.width / 2, creditY);
        }
        
        /**
         * タイトル画面を描画する
         */
        function drawTitleScreen() {
            // 背景グラデーション
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#2c5aa0');
            gradient.addColorStop(0.5, '#5b3a8f');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 星を描画
            ctx.fillStyle = 'white';
            for (let i = 0; i < 20; i++) {
                const x = (i * 47) % canvas.width;
                const y = (i * 23) % (canvas.height * 0.6);
                ctx.fillRect(x, y, 2, 2);
            }

            // ヨガ行者のドット絵を描画
            drawYogaMonk();

            // 画面サイズに応じてフォントサイズを調整
            const isSmallScreen = canvas.height < 600;
            const titleFontSize = isSmallScreen ? 24 : 32;
            const subtitleFontSize = isSmallScreen ? 14 : 16;
            const conceptFontSize = isSmallScreen ? 13 : 15;
            const instructionFontSize = isSmallScreen ? 16 : 18;
            const versionFontSize = isSmallScreen ? 12 : 14;
            const pwaNoteFontSize = isSmallScreen ? 10 : 12;

            // タイトルテキスト
            ctx.fillStyle = 'white';
            ctx.font = `bold ${titleFontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeText('魂テトリス', canvas.width / 2, canvas.height * 0.15);
            ctx.fillText('魂テトリス', canvas.width / 2, canvas.height * 0.15);

            // サブタイトル
            ctx.font = `${subtitleFontSize}px Arial`;
            ctx.fillStyle = '#cccccc';
            ctx.fillText('~ Soul Tetris ~', canvas.width / 2, canvas.height * 0.22);

            // コンセプトメッセージ
            ctx.font = `${conceptFontSize}px Arial`;
            ctx.fillStyle = '#ffd700'; // ゴールド色で神聖さを表現
            const conceptY = isSmallScreen ? canvas.height * 0.62 : canvas.height * 0.65;
            ctx.fillText('邪気を浄化して魂のステージを上げよう！', canvas.width / 2, conceptY);

            // ハイスコアボタン
            drawHighScoreButton();

            // ゲーム開始の説明（ボタンの下に配置）
            ctx.font = `${instructionFontSize}px Arial`;
            ctx.fillStyle = 'white';
            const instructionY = isSmallScreen ? canvas.height * 0.88 : canvas.height * 0.85;
            ctx.fillText('画面をタップしてゲーム開始', canvas.width / 2, instructionY);

            // PWA案内とバージョン情報（画面下部）
            ctx.font = `${pwaNoteFontSize}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.textAlign = 'center';
            const pwaY = canvas.height - (isSmallScreen ? 25 : 30);
            ctx.fillText('※ホーム画面に追加でこのゲームをアプリ化', canvas.width / 2, pwaY);

            // バージョン情報（右下に配置）
            ctx.font = `${versionFontSize}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.textAlign = 'right';
            ctx.fillText('Ver. 0.55', canvas.width - 10, canvas.height - 10);
        }

        /**
         * BGMを読み込む
         */
        function loadBGM() {
            try {
                bgmAudio = new Audio('soul-stage.mp3');
                bgmAudio.loop = true;
                bgmAudio.volume = 0.7;
                bgmAudio.preload = 'auto';
                bgmAudio.addEventListener('canplaythrough', () => console.log('BGMの読み込み完了'));
                bgmAudio.addEventListener('error', (e) => {
                    console.error('BGMの読み込みに失敗しました:', e);
                    bgmAudio = null;
                });
            } catch (error) {
                console.error('BGMの初期化に失敗しました:', error);
                bgmAudio = null;
            }
        }

        /**
         * ゲームオーバー用BGMを読み込む
         */
        function loadGameOverBGM() {
            try {
                gameoverBgmAudio = new Audio('soul-gameover.mp3');
                gameoverBgmAudio.loop = false;
                gameoverBgmAudio.volume = 0.7;
                gameoverBgmAudio.preload = 'auto';
                gameoverBgmAudio.addEventListener('canplaythrough', () => console.log('ゲームオーバーBGMの読み込み完了'));
                gameoverBgmAudio.addEventListener('error', (e) => {
                    console.error('ゲームオーバーBGMの読み込みに失敗しました:', e);
                    gameoverBgmAudio = null;
                });
            } catch (error) {
                console.error('ゲームオーバーBGMの初期化に失敗しました:', error);
                gameoverBgmAudio = null;
            }
        }

        /**
         * タイトル用BGMを読み込む
         */
        function loadTitleBGM() {
            try {
                titleBgmAudio = new Audio('soul-title.mp3');
                titleBgmAudio.loop = true;
                titleBgmAudio.volume = 0.7;
                titleBgmAudio.preload = 'auto';
                titleBgmAudio.addEventListener('canplaythrough', () => console.log('タイトルBGMの読み込み完了'));
                titleBgmAudio.addEventListener('error', (e) => {
                    console.error('タイトルBGMの読み込みに失敗しました:', e);
                    titleBgmAudio = null;
                });
            } catch (error) {
                console.error('タイトルBGMの初期化に失敗しました:', error);
                titleBgmAudio = null;
            }
        }
        
        /**
         * ブラウザの音声再生制限を解除する
         */
        function unlockAudioFiles() {
            let unlocked = false;
            const unlock = () => {
                if (unlocked) return;
                unlocked = true;

                // タイトルBGMは個別の再生ロジックで扱うため、ここでは除外
                const audios = [bgmAudio, gameoverBgmAudio].filter(a => a);
                audios.forEach(audio => {
                    // Play and immediately pause each audio to unlock it.
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            audio.pause();
                            audio.currentTime = 0;
                            console.log(`${audio.src.split('/').pop()} がアンロックされました`);
                        }).catch(error => {
                            // Autoplay was prevented. This is expected on some browsers.
                            // The user interaction should allow future plays.
                            console.warn(`${audio.src.split('/').pop()} のアンロックに失敗 (自動再生がブロックされました):`, error);
                        });
                    }
                });
            };

            // Unlock on the first user interaction.
            document.body.addEventListener('click', unlock, { once: true });
            document.body.addEventListener('touchend', unlock, { once: true });
        }

        /**
         * BGMを再生する
         */
        function playBGM() {
            if (bgmAudio) {
                try {
                    bgmAudio.currentTime = 0;
                    const playPromise = bgmAudio.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => console.error('BGM再生に失敗しました:', error));
                    }
                } catch (error) {
                    console.error('BGM再生エラー:', error);
                }
            }
        }
        
        /**
         * BGMを停止する
         */
        function stopBGM() {
            if (bgmAudio && !bgmAudio.paused) {
                bgmAudio.pause();
                bgmAudio.currentTime = 0;
            }
        }

        /**
         * タイトルBGMを再生する
         */
        function playTitleBGM() {
            if (titleBgmAudio) {
                try {
                    titleBgmAudio.currentTime = 0;
                    const playPromise = titleBgmAudio.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => console.error('タイトルBGMの再生に失敗:', error));
                    }
                } catch (error) {
                    console.error('タイトルBGM再生エラー:', error);
                }
            }
        }
        
        /**
         * タイトルBGMを停止する
         */
        function stopTitleBGM() {
            if (titleBgmAudio && !titleBgmAudio.paused) {
                titleBgmAudio.pause();
                titleBgmAudio.currentTime = 0;
            }
        }

        /**
         * ゲームオーバー用BGMを再生する
         */
        function playGameOverBGM() {
            if (gameoverBgmAudio) {
                try {
                    gameoverBgmAudio.currentTime = 0;
                    const playPromise = gameoverBgmAudio.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => console.error('ゲームオーバーBGM再生に失敗しました:', error));
                    }
                } catch (error) {
                    console.error('ゲームオーバーBGM再生エラー:', error);
                }
            }
        }

        /**
         * ゲームオーバー用BGMを停止する
         */
        function stopGameOverBGM() {
            if (gameoverBgmAudio && !gameoverBgmAudio.paused) {
                gameoverBgmAudio.pause();
                gameoverBgmAudio.currentTime = 0;
            }
        }
        
        /**
         * ヨガ画像を読み込む
         */
        function loadYogaImage() {
            const img = new Image();
            img.onload = () => {
                yogaImage = img;
                console.log('ヨガ画像の読み込み成功');
                if (gameState === 'title') {
                    drawTitleScreen();
                }
            };
            img.onerror = () => {
                console.error('ヨガ画像の読み込みに失敗しました');
                yogaImage = null; // 画像がない場合でもエラーにならないようにする
            };
            img.src = 'yoga01.png';
        }

        /**
         * ヨガ行者の画像を描画する
         */
        function drawYogaMonk() {
            if (!yogaImage) return; // 画像が読み込まれていない場合は何もしない

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            const maxImageWidth = canvas.width * 0.4;
            const maxImageHeight = canvas.height * 0.4;
            
            const scale = Math.min(
                maxImageWidth / yogaImage.width,
                maxImageHeight / yogaImage.height
            );
            
            const imageWidth = yogaImage.width * scale;
            const imageHeight = yogaImage.height * scale;
            
            const imageX = centerX - imageWidth / 2;
            const imageY = centerY - imageHeight / 2 - 20;

            // 光輪（オーラ）
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY - 20, Math.max(imageWidth, imageHeight) / 2 + 40, 0, Math.PI * 2);
            ctx.stroke();

            // ヨガ行者の画像
            ctx.drawImage(yogaImage, imageX, imageY, imageWidth, imageHeight);
        }

        /**
         * ハイスコアボタンを描画する
         */
        function drawHighScoreButton() {
            const isSmallScreen = canvas.height < 600;
            const buttonWidth = Math.min(canvas.width * 0.3, 200);
            const buttonHeight = isSmallScreen ? 35 : 40;
            const buttonX = canvas.width / 2 - buttonWidth / 2;
            const buttonY = canvas.height * (isSmallScreen ? 0.70 : 0.75);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);

            ctx.fillStyle = 'white';
            ctx.font = `${isSmallScreen ? 16 : 18}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('ハイスコア', canvas.width / 2, buttonY + (buttonHeight / 2) + 5);
        }

        /**
         * ハイスコア画面を描画する
         */
        function drawHighScoreScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'white';
            ctx.font = '28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ハイスコア', canvas.width / 2, canvas.height * 0.3);
            
            ctx.font = '20px Arial';
            ctx.fillText('1位: 50,000', canvas.width / 2, canvas.height * 0.45);
            ctx.fillText('2位: 35,000', canvas.width / 2, canvas.height * 0.52);
            ctx.fillText('3位: 20,000', canvas.width / 2, canvas.height * 0.59);
            ctx.fillText('4位: 15,000', canvas.width / 2, canvas.height * 0.66);
            ctx.fillText('5位: 10,000', canvas.width / 2, canvas.height * 0.73);
            
            ctx.font = '16px Arial';
            ctx.fillStyle = '#cccccc';
            ctx.fillText('画面をタップして戻る', canvas.width / 2, canvas.height * 0.85);
        }

        /**
         * ハイスコアボタンがタップされたかチェックする
         */
        function isHighScoreButtonTapped(x, y) {
            const isSmallScreen = canvas.height < 600;
            const buttonWidth = Math.min(canvas.width * 0.3, 200);
            const buttonHeight = isSmallScreen ? 35 : 40;
            const buttonX = canvas.width / 2 - buttonWidth / 2;
            const buttonY = canvas.height * (isSmallScreen ? 0.70 : 0.75);
            
            return x >= buttonX && x <= buttonX + buttonWidth && 
                   y >= buttonY && y <= buttonY + buttonHeight;
        }

        /**
         * ゲームオーバー画面を描画する
         */
        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ゲームオーバー', canvas.width / 2, canvas.height / 2 - 40);
            ctx.font = '20px Arial';
            ctx.fillText(`最終スコア: ${score}`, canvas.width / 2, canvas.height / 2);
            ctx.font = '16px Arial';
            ctx.fillStyle = '#cccccc';
            ctx.fillText('タップしてタイトルに戻る', canvas.width / 2, canvas.height / 2 + 40);
        }

        /**
         * ゲームをリセットして新しいゲームを開始する
         */
        function resetGame() {
            sandParticles = [];
            score = 0;
            comboCount = 0;
            maxCombo = 0;
            isSettling = false;
            isClearing = false;
            frameCount = 0;
            lastClearedTime = 0;
            currentPiece = createPiece();
            nextPiece = createPiece();
            fallSpeed = 30;
            totalRows = 0;
            updateScoreDisplay();
            gameState = 'playing';
            
            stopTitleBGM();
            stopGameOverBGM();
            playBGM();
            
            update();
        }

        /**
         * メインゲームループ
         */
        function update() {
            if (gameState !== 'playing') return;

            frameCount++;
            
            // ピースの自動落下
            if (frameCount % Math.floor(fallSpeed) === 0 && !isSettling && !isClearing && currentPiece) {
                if (canMove(0, 1)) {
                    currentPiece.y++;
                    score++;
                    totalRows++;
                    
                    // スピードアップ
                    if (totalRows > 0 && totalRows % SPEED_INCREASE_INTERVAL === 0) {
                        fallSpeed *= SPEED_INCREASE_RATE;
                    }
                } else {
                    mergePiece();
                    isSettling = true;
                }
            }

            // 砂粒子の物理シミュレーション
            if (isSettling) {
                if (!simulateSand()) {
                    isSettling = false;
                    isClearing = true;
                }
            }

            // ライン消去処理
            if (isClearing) {
                const cleared = checkAndClearLines();
                if (cleared) {
                    isSettling = true;
                } else {
                    isClearing = false;
                    if (!currentPiece) {
                        currentPiece = nextPiece;
                        nextPiece = createPiece();
                        if (!canMove(0, 0)) {
                            gameOver();
                            return;
                        }
                    }
                }
            }

            // 描画
            drawGrid();
            if (currentPiece && !isSettling && !isClearing) {
                drawPiece();
            }
            drawNextPiece();
            drawPauseButton(); // ポーズボタンを描画

            updateScoreDisplay();
            gameLoop = requestAnimationFrame(update);
        }

        /**
         * タッチ操作を処理する
         */
        function handleTouch(action) {
            if (gameState !== 'playing' || !currentPiece) return;

            switch (action) {
                case 'left':
                    if (canMove(-1, 0)) currentPiece.x--;
                    break;
                case 'right':
                    if (canMove(1, 0)) currentPiece.x++;
                    break;
                case 'rotate':
                    rotate();
                    break;
                case 'drop':
                    while (canMove(0, 1)) {
                        currentPiece.y++;
                        score++;
                        totalRows++;
                    }
                    mergePiece();
                    isSettling = true;
                    break;
            }
        }

        /**
         * 画面タップ/クリックの共通処理
         */
        function handleScreenTap(x, y) {
            switch (gameState) {
                case 'pleaseTap':
                    if (pleaseTapAnimation) {
                        cancelAnimationFrame(pleaseTapAnimation);
                        pleaseTapAnimation = null;
                    }
                    gameState = 'title';
                    // [修正] 他のBGMが再生されている可能性を考慮し、ここで停止させる
                    stopBGM();
                    stopGameOverBGM();
                    playTitleBGM();
                    drawTitleScreen();
                    break;
                case 'title':
                    if (isHighScoreButtonTapped(x, y)) {
                        gameState = 'highscore';
                        drawHighScoreScreen();
                    } else {
                        resetGame();
                    }
                    break;
                case 'highscore':
                    gameState = 'title';
                    // playTitleBGM(); // BGMを再生し直さないようにコメントアウト
                    drawTitleScreen();
                    break;
                case 'gameOver':
                    gameState = 'title';
                    stopGameOverBGM();
                    playTitleBGM();
                    drawTitleScreen();
                    break;
            }
        }

        /**
         * ポーズ画面を描画する
         */
        function drawPauseScreen() {
            // ゲームエリアに完全に不透明なオーバーレイを描画
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, cellSize * gridWidth, canvas.height);

            // ポーズテキストを描画
            ctx.fillStyle = 'white';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('PAUSED', (cellSize * gridWidth) / 2, canvas.height / 2 - 20);
            
            ctx.font = '16px Arial';
            ctx.fillText('タップして再開', (cellSize * gridWidth) / 2, canvas.height / 2 + 20);
        }

        /**
         * ポーズボタンを描画する
         */
        function drawPauseButton() {
            const nextPieceAreaWidth = canvas.width - cellSize * gridWidth;
            const nextAreaX = cellSize * gridWidth;
            
            const buttonWidth = nextPieceAreaWidth * 0.6;
            const buttonHeight = 40;
            const buttonX = nextAreaX + (nextPieceAreaWidth - buttonWidth) / 2;
            const buttonY = canvas.height - buttonHeight - 20; // NEXTエリアの下部に配置

            // クリック検出用に座標を保存
            pauseButton = { x: buttonX, y: buttonY, width: buttonWidth, height: buttonHeight };

            // ボタンを描画
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(pauseButton.x, pauseButton.y, pauseButton.width, pauseButton.height);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(pauseButton.x, pauseButton.y, pauseButton.width, pauseButton.height);

            // テキストを描画
            ctx.fillStyle = 'white';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Pause', pauseButton.x + pauseButton.width / 2, pauseButton.y + pauseButton.height / 2);
        }

        /**
         * ポーズボタンがタップされたかチェックする
         */
        function isPauseButtonTapped(x, y) {
            return x >= pauseButton.x && x <= pauseButton.x + pauseButton.width &&
                   y >= pauseButton.y && y <= pauseButton.y + pauseButton.height;
        }

        /**
         * イベントリスナーを初期化する
         */
        function initEventListeners() {
            function handleTap(x, y) {
                // ポーズ状態の解除が最優先
                if (gameState === 'paused') {
                    gameState = 'playing';
                    playBGM();
                    update();
                    return;
                }

                // プレイ中にポーズボタンが押された場合
                if (gameState === 'playing' && isPauseButtonTapped(x, y)) {
                    gameState = 'paused';
                    stopBGM();
                    cancelAnimationFrame(gameLoop);
                    drawPauseScreen();
                    return;
                }
                
                // その他のゲーム状態の処理
                handleScreenTap(x, y);
            }

            // タッチ開始
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState === 'playing') {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    touchStartTime = Date.now();
                    isTouchHolding = true;
                }
            }, { passive: false });

            // タッチ移動
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (gameState !== 'playing' || !isTouchHolding) return;

                const touch = e.touches[0];
                const deltaX = touch.clientX - touchStartX;
                const deltaY = touch.clientY - touchStartY;

                if (Math.abs(deltaX) > cellSize) {
                    handleTouch(deltaX > 0 ? 'right' : 'left');
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }

                if (deltaY > cellSize * 2) {
                    handleTouch('drop');
                    isTouchHolding = false;
                }
            }, { passive: false });

            // タッチ終了
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                if (gameState === 'playing') {
                    // ポーズボタンのタップ判定を先に行う
                    if (isPauseButtonTapped(x, y)) {
                        handleTap(x, y);
                        return;
                    }
                    const touchEndTime = Date.now();
                    const touchDuration = touchEndTime - touchStartTime;
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;

                    if (touchDuration < 250 && Math.abs(deltaX) < 20 && Math.abs(deltaY) < 20 && isTouchHolding) {
                        handleTouch('rotate');
                    }
                    isTouchHolding = false;
                } else {
                    handleTap(x, y);
                }
            }, { passive: false });

            // クリックイベント（デスクトップ用）
            canvas.addEventListener('click', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                handleTap(x, y);
            });

            // ウィンドウリサイズ
            window.addEventListener('resize', () => {
                resizeCanvas();
                switch (gameState) {
                    case 'pleaseTap': drawPleaseTapScreen(); break;
                    case 'title': drawTitleScreen(); break;
                    case 'highscore': drawHighScoreScreen(); break;
                    case 'gameOver': drawGameOverScreen(); break;
                    case 'playing':
                         drawGrid();
                         if(currentPiece) drawPiece();
                         if(nextPiece) drawNextPiece();
                         break;
                }
            });
        }

        /**
         * ゲームを初期化する
         */
        function init() {
            resizeCanvas();
            loadBGM();
            loadTitleBGM();
            loadGameOverBGM();
            loadYogaImage();
            
            initEventListeners();
            unlockAudioFiles(); // ユーザーの最初の操作を待ってオーディオを有効にする
            
            gameState = 'pleaseTap';
            animatePleaseTapScreen();
            
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('service-worker.js')
                    .then(reg => console.log('Service Worker登録成功:', reg))
                    .catch(err => console.log('Service Worker登録失敗:', err));
            }
        }

        // ゲーム開始
        init();
    </script>
</body>
</html>
